---
title: 生命周期
date: 2024-05-27 17:14:16
permalink: /pages/ed0bda/
categories:
  - 《Vue2》笔记
  - 生命周期
tags:
  - Vue2
author: 
  name: Regulus
  link: https://github.com/linxi0551
---

Vue 生命周期又名生命周期回调函数、生命周期函数、生命周期钩子，是 Vue在关键时刻帮我们调用的一些特殊名称的函数。所有生命周期函数中的 this 都是指向 vm 或 vue 组件实例对象。

---

<center><big style="color: yellow;">生命周期示例图</big></center>
<p class='centered'><img src="https://cdn.nlark.com/yuque/0/2024/png/40965929/1716788166447-f37d47a4-5831-4446-a638-d420c71c6f3f.png#averageHue=%23fbf9f8&clientId=uc48aed68-7f50-4&from=paste&height=1270&id=u88218470&originHeight=1892&originWidth=1469&originalType=binary&ratio=1&rotation=0&showTitle=false&size=373744&status=done&style=stroke&taskId=ufdc7e61d-80e2-4269-a939-87a808cd0be&title=&width=986" width="800" style="cursor: zoom-in;"></p>

生命周期示例代码：

```vue
<template>
  <div id="app">
    <h2>vue生命周期</h2>
    <h3>当前的n值是：{{ n }}</h3>
    <button @click="add">点我n+1</button>
    <button @click="bye">点我销毁vm</button>
  </div>
</template>
<script>
  export default {
    data() {
      return {
        n: 1,
      };
    },
    methods: {
      add() {
        console.log("add");
        this.n++;
      },
      bye() {
        console.log("bye");
        this.$destroy();
      },
    },
    //组件创建之前调用
    beforeCreate() {
      console.log("beforeCreate");
    },
    //组件创建之后调用
    created() {
      console.log("created");
    },
    //在组件被挂载之前调用
    beforeMount() {
      console.log("beforeMount");
    },
    //在组件被挂载之后调用
    mounted() {
      console.log("mounted");
    },
    //组件更新之前调用
    beforeUpdate() {
      console.log("beforeUpdate");
    },
    //组件更新之后调用
    updated() {
      console.log("updated");
    },
    //组件被销毁之前调用
    beforeDestroy() {
      console.log("beforeDestroy");
    },
    //组件被销毁之后调用
    destroyed() {
      console.log("destroyed");
    },
  };
</script>
<style scoped>
  #app {
    margin-left: 50px;
    width: 100%;
    height: 100%;
  }
  #app button:not(:last-child) {
    margin-right: 10px;
  }
</style>
```


::: tip 以下是在各个生命周期函数中加入  debugger  断点后的演示：
:::

### 1、beforeCreate
组件创建之前调用

图示：
<p class='centered'><img src="https://cdn.nlark.com/yuque/0/2024/png/40965929/1716795601752-a6b2d3e1-bae2-4ee7-9f5d-6e3b884279d8.png#averageHue=%23efeeee&clientId=uc48aed68-7f50-4&from=paste&height=710&id=u059904fe&originHeight=919&originWidth=1083&originalType=binary&ratio=1&rotation=0&showTitle=false&size=50129&status=done&style=stroke&taskId=u6752cc0e-569e-4c41-bfa1-0fb0b81eee4&title=&width=837" width="840" style="cursor: zoom-in;"></p>
总结：

- 当我们把  `debugger`  断点设置在 **beforeCreate** 中，可以看到图中打印了  **beforeCreate** 和 Vue 组件实例对象，当我们打开  **VueComponent**  就会发现 数据代理  `_data`  和  `methods`  回调函数还未创建。

### 2、created
组件创建之后调用

图示：
<p class='centered'><img src="https://cdn.nlark.com/yuque/0/2024/png/40965929/1716796263433-bc2aee3a-0ae7-46f0-8466-056e6d3fd359.png#averageHue=%23eeeded&clientId=uc48aed68-7f50-4&from=paste&height=834&id=u17f96800&originHeight=834&originWidth=1107&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38400&status=done&style=stroke&taskId=ub4abaeb4-e106-4b4d-95e9-c75a0b6c182&title=&width=1107" width="840" style="cursor: zoom-in;"></p>
总结：

- 当我们把  `debugger`  断点设置在  **created**   中，可以看到图中 Vue 组件实例对象中数据代理  `_data`  和  `methods`  回调函数已经创建。

### 3、beforeMount
在组件被挂载之前调用

图示：
<p class='centered'><img src="https://cdn.nlark.com/yuque/0/2024/png/40965929/1716797343306-e6e778a3-a842-440c-a6c1-ed68cbfb2856.png#averageHue=%23e6e6e6&clientId=uc48aed68-7f50-4&from=paste&height=584&id=u0161ebba&originHeight=584&originWidth=1120&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27045&status=done&style=stroke&taskId=u1e458407-4444-487f-9bd7-b9f9413728f&title=&width=1120" width="840" style="cursor: zoom-in;"></p>
总结：

- 在  `beforeMount`  中，你可以访问组件的属性（如data、methods等），但不能访问  `$el`  或  `$refs`  ，因为此时组件尚未挂载到DOM中。

### 4、mounted
在组件挂载之后调用

图示：
<p class='centered'><img src="https://cdn.nlark.com/yuque/0/2024/png/40965929/1716797919557-8017c98f-0bf6-4df1-bf92-99cb57586d92.png#averageHue=%23e9e9e9&clientId=uc48aed68-7f50-4&from=paste&height=723&id=uccc1f055&originHeight=723&originWidth=1108&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38844&status=done&style=stroke&taskId=u1b6bcdc8-039f-4dc9-9015-503c2ff2350&title=&width=1108" width="840" style="cursor: zoom-in;"></p>
总结：

- 当断点设置在 `mounted` 中，所有虚拟 DOM 已经被渲染为真是 DOM 并插入到指定 DOM 元素中，这时候可以使用  `this.$el`  访问组件的根元素，并进行DOM操作，也可以发起异步请求。

::: warning
即使组件被挂载，其子组件可能还没有被挂载。如果你需要等待所有子组件都挂载完成，可以使用以下代码进行操作
:::


``` vue
<script>
……
mounted() {
  this.$nextTick(() => {
    // 在这里，所有子组件也都已挂载完成
    console.log('所有子组件都已挂载');
  });
}
</script>
```
### 5、beforeUpdate
组件更新之前调用

图示：
<p class='centered'><img src="https://cdn.nlark.com/yuque/0/2024/png/40965929/1716798761895-a627816c-5c4f-4d87-b0f2-c6c768ad0a3c.png#averageHue=%23eae9e8&clientId=uc48aed68-7f50-4&from=paste&height=737&id=u2299ae48&originHeight=737&originWidth=1106&originalType=binary&ratio=1&rotation=0&showTitle=false&size=45928&status=done&style=stroke&taskId=u27dfaebf-58e4-4975-87cc-c499f038236&title=&width=1106" width="840" style="cursor: zoom-in;"></p>

总结：

- 当断点设置在  `beforeUpdate`  中，并点击 **"点我 n+1 按钮"** ,会发现  **VueComponent**  中的数据已更新，但页面还未渲染。

### 6、updated
组件更新之后调用

图示：
<p class='centered'><img src="https://cdn.nlark.com/yuque/0/2024/png/40965929/1716799157603-0388b087-ead8-4d52-83ce-511fbc27085d.png#averageHue=%23e8e7e7&clientId=uc48aed68-7f50-4&from=paste&height=681&id=u03761a91&originHeight=681&originWidth=1227&originalType=binary&ratio=1&rotation=0&showTitle=false&size=37819&status=done&style=stroke&taskId=uc35642e4-042c-4ede-9ce3-c1122d607fc&title=&width=1227" width="840" style="cursor: zoom-in;"></p>
总结：

- 可以看到上图中的页面和数据已经同步。

### 7、beforeDestroy
组件被销毁之前调用

图示：
<p class='centered'><img src="https://cdn.nlark.com/yuque/0/2024/png/40965929/1716799438905-5ecc3a49-13c6-43eb-bed7-5d6631895078.png#averageHue=%23dedddd&clientId=uc48aed68-7f50-4&from=paste&height=460&id=uac650867&originHeight=460&originWidth=1066&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24245&status=done&style=stroke&taskId=ub6bc5c27-9fe2-4720-8a6d-73c10db9b6e&title=&width=1066" width="840" style="cursor: zoom-in;"></p>

总结：

- 在这个阶段，组件实例仍然有效，但即将被销毁，你可以在这里执行清理工作，例如：
   - 取消定时器：如果你在组件中设置了定时器（如  `setInterval`  或  `setTimeout`  ），应该在这个阶段清除它们，以避免内存泄漏。
   - 解除监听器：如果你使用了  `watch`  或  `$on`  添加了事件监听器，记得在组件销毁前移除它们。
   - 关闭连接：如果你的组件与服务器或其他资源建立了连接，可以在这个阶段关闭它们。
   - 清理其他资源：释放组件可能占用的任何其他资源，如Web Workers、WebSocket连接等。

### 8、destroyed
组件被销毁之后调用

图示：
<p class='centered'><img src="https://cdn.nlark.com/yuque/0/2024/gif/40965929/1716800961710-a0e6b31c-8a5d-4e38-a791-fa010ec3aa95.gif#averageHue=%23f4f5fb&clientId=uc48aed68-7f50-4&from=paste&height=446&id=u790c266e&originHeight=446&originWidth=316&originalType=binary&ratio=1&rotation=0&showTitle=false&size=52210&status=done&style=stroke&taskId=ua9a5b1d6-7674-4d8f-8f2b-83e5140324f&title=&width=316" width="400" style="cursor: zoom-in;"></p>

总结：
 **destroyed** 是 Vue 组件生命周期中的最后一个钩子，它在组件实例被销毁后调用。这意味着组件实例和它的所有子组件已经被完全移除，不再存在，这时候点击按钮是没有任何效果的。
