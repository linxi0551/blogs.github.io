---
title: 加密的那些事
date: 2024-05-31 10:20:16
permalink: /pages/07c91f/
titleTag: 原创
categories:
  - 技术
  - 心得
tags:
  - 
author: 
  name: Regulus
  link: https://github.com/linxi0551
---

::: tip 序言

不论是前端还是后端开发中，数字签名、信息加密是经常需要使用到的技术，应用场景包括了用户登入、交易、信息通讯、OAuth 等等，不同的应用场景也会需要使用到不同的签名加密算法，或者需要搭配不一样的 签名加密算法 来达到业务目标。

:::
<!-- 
[幻灯片模式](/slides/slides.html) -->
[幻灯片模式](/pages/07c911/)

<!-- <script>
  window.location.href = '/slides/slides.html';
</script> -->

## 历史上的密码

<!-- **漫画**：https://cloud.tencent.com/developer/article/1394806 -->

<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/04/zbw5goanfw.jpg' width="700" style="cursor: zoom-in;"></p>

早在古罗马时期，加密算法就被应用于战争当中。 在大规模的战争中，部队之间常常需要信使往来，传递重要的军事情报。 

<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/03/s81l0wvnzd.jpg' width="700" style="cursor: zoom-in;"></p>

可是，一旦信使被敌军抓获，重要的军事情报就完全暴露给了敌方。

<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/03/thtjd7mn2l.jpg' width="700" style="cursor: zoom-in;"></p>

甚至，狡猾的敌人有可能篡改军事情报，并收买信使把假情报传递给我方部队。

<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/03/5rl2i6buw1.jpg' width="700" style="cursor: zoom-in;"></p>

<!-- <p class="centered"><img src='https://ask.qcloudimg.com/http-save/yehe-2960417/5rl2i6buw1.jpeg?imageView2/2/w/1620' width="700" style="cursor: zoom-in;"></p> -->

### 凯撒密码

传送情报过程中，容易遭到**中间人攻击**，怎样防止这种情况的发生呢？ 古罗马时期，凯撒大帝想出了一种非常朴素的加密方法，这套加密方法也被后世称为**凯撒密码**。加密的原理就像下图这样： 

<p class="centered"><img src='https://ask.qcloudimg.com/http-save/yehe-2960417/ltlt3t6nuf.png?imageView2/2/w/1620' width="700" style="cursor: zoom-in;"></p>


原理其实非常简单，就是把字母表进行**移位加密**，比如将字母表中的 A 移位加密后变成 C，将字母表中的 B 移位加密后变成 D，以此类推。

<center><strong><big> 下面是更直观的示例 </big></strong></center>

<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/03/_20240603113844.png' width="620" style="cursor: zoom-in;"></p>

**凯撒密码**在当时是一种有效的加密方法，它是典型的**对称加密**算法，它的加密和解密密钥用的都是同一个密钥，加密的时候字母表平移了几位，解密的时候只要反向平移就能得到原文。

这也导致凯撒密码的**安全性较低**，因为只需尝试26个不同的位移就能<span style="color:red;">暴力破解</span>。

<center><strong><big> 下面是暴力破解凯撒密码的示例 </big></strong></center>

<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/03/_20240603140434.png' width="620" style="cursor: zoom-in;"></p>


## 计算机时代的密码

现代加密技术在凯撒密码的基础上进行了改进，采用了更复杂的加密算法，如**对称加密（AES、DES）**和**非对称加密（RSA）**。

### 对称密码

对称密码是一种加密技术，它使用**相同的密钥**来进行数据的加密和解密过程。

#### 二进制编码

学过计算机的都知道，在计算机的世界，所有数据都是以二进制的形式存储的，计算机的运算都是基于二进制的，每个字母当然也是一串二进制数字。

<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/03/_20240603145534.png' width="620" style="cursor: zoom-in;"></p>



<!-- 为什么讲这个，是因为字母是没办法做数学计算的，没办法做加减乘除，但是只要把它转换成编码变成了数字，那么它就能进行简单的数学运算。 -->

#### 异或运算

**异或运算**(`XOR`)是一种常见的位操作运算,相同位为0，不同位为1。

<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/03/_20240603154039.png' width="350" style="cursor: zoom-in;"></p>


**异或运算**有一个非常好的性质，它的性质就是下面这张图

<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/03/_20240603171743.png' width="350" style="cursor: zoom-in;"></p>

上图中`A`可以理解为**明文**，`B`可以理解为**密钥**，`A`和`B`异或，那么`A`和`B`异或得到的结果就是**密文**。反之，**密文**和**密钥**进行异或，那么得到的结果就是**明文**`A`。

<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/03/_20240603175831.png' width="700" style="cursor: zoom-in;"></p>

上图中字母`D`可以理解为**明文**，蒙版可以理解为**密钥**，`D`和蒙版做异或运算，就会得到一张没有任何信息的图，也就是**密文**。

解密时只要把得到的**密文**和蒙版做异或运算就能得到了字母`D`也就是**明文**。这就是对称加密算法的基本原理。



### 分组密码模式

::: tip 现在用的比较多的对称加密算法有DES和AES，这两个算法都是把明文切成固定的比特长度大小，再进行复杂的位运算加密，但它们本身只处理固定长度的数据块（例如AES处理128位数据块）。为了适应不同长度的明文信息，保护数据的完整性和安全性，这时候就需要引入分组密码模式。
:::

常见的分组密码模式有五种，分别是：**电码本模式（ECB模式）**、**密码分组链接模式（CBC模式）**、**密文反馈模式（CFB）**、**输出反馈模式（OFB）**、**计数器模式（CTR）**。

#### 明文分组和密文分组

::: tip 在介绍模式之前，我们先来学习两个术语。

<mark>明文分组:</mark> 是指分组密码算法中作为加密对象的明文。明文分组的长度与分组密码算法的分组长度是相等的。

<mark>密文分组:</mark> 是指使用分组密码算法将明文分组加密之后所生成的密文。
:::



<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/11/e1d6157e726360b8c83cc8629e1b123.png' width="700" style="cursor: zoom-in;"></p>

::: tip 为了避免图示变得复杂，以后我们将 "分组密码算法加密" 简写为 "加密"，并省略对密钥的描述。
:::

#### 电码本模式（ECB模式）

<!-- ::: details 描述 -->

**电码本模式**的名称来源于其工作原理与传统纸质电话簿的类比。在传统的电话簿中，联系人姓名 **（类似于明文）** 与对应的电话号码 **（可类比为密文）** 是按字母顺序排列的，每个人（或每个条目）的电话号码都是独立记录的，相互之间没有关联。当你查找某个人的电话号码时，可以直接定位到该姓名对应的条目，而不需要了解或参考其他人的信息。

相似地，在**ECB加密模式**中，明文被切分为若干个数据块，每个数据块独立地通过相同的密钥和加密算法转换成相应的密文块，这些密文块之间也是**独立且无关联**的，就像电话簿中的每个条目独立记录一样。因此，这种 **"一对一"** 映射的加密方式与电话簿的使用方式相类似，故被称为“电码本”模式。

<!-- ::: -->


<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/04/_20240604155659.png' width="700" style="cursor: zoom-in;"></p>

从上图中可以看到每个数据块都是**独立加密**的，块与块之间不存在任何联系，所以加密的时候可**并行**加密，速度非常快，而且实现也简单。这种模式适用于**无重复数据**的短消息加密场景。这是**ECB模式**的优点。

那这个模式有什么缺点呢，可以看下下面这个例子👇：

<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/07/fda187c5d4bf9d3f01f9e3d35d12742.png' width="700" style="cursor: zoom-in;"></p>

在这个场景中我们可以将付款人银行账号、收款人银行账号和转账金额进行分组，得到明文分组1、2、3的16进制表示的ASCII码序列，通过分组加密后得到分组密文，这时候只知道密文分组1是付款人、密文分组2是收款人、密文分组3是转账金额。至于具体的内容并不知道，因为进行了加密。


:::  warning 如果这个时候有黑客攻击，他会用什么手段进行攻击呢？
:::

::: details
其实很简单，可以看下面这副图👇：

<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/07/7f96709cce53a75294af2e76e7d5446.png' width="700" style="cursor: zoom-in;"></p>

攻击者并不需要密钥解密密文，就可以直接操作密文从而影响明文，只要对密文块进行**重新排序**，就能让解密后的付款人和收款人的顺序进行互换，这对银行转账业务来说是致命的。

这就是ECB模式的重要缺陷之一，它**缺乏扩散性**，每个数据块独立加密，彼此之间不存在关联，容易被密文**重排序**攻击。并且相同的明文无论出现在哪个位置都会被**加密成相同的密文**，这导致它模式是**可预测性**的。

那有什么办法解决这个问题呢？答案是下面的模式👇。

:::


#### 密码分组链接模式（CBC模式）

<!-- ::: details 描述 -->

**密码分组链接模式**得名于其特有的工作原理，即每个明文分组在加密之前会与前一个密文分组进行 **"链接"**（通常是异或操作）。这个 **"链接"** 过程确保了当前分组的加密不仅依赖于当前分组的明文和密钥，还依赖于前一个分组的加密结果，形成了 **"链式"** 反应，故此得名**密码分组链接模式**。

<!-- ::: -->

<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/07/_20240607101439.png' width="700" style="cursor: zoom-in;"></p>

<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/07/88e3616a82c8ad93f1be7a0a756e609.png' width="700" style="cursor: zoom-in;"></p>

上图是**CBC模式**加解密过程，我们可以拆分成以下几个步骤👇：

加密的过程：

::: details

1. 首先将明文切成若干组。

2. 在开始加密前，明文分组1先和初始向量进行异或运算（这里的初始向量是一个随机数，用于确保相同的明文在每次加密时生成不同的密文）。

3. 再用密钥对明文分组1和初始向量异或的结果进行加密，得到密文分组1。

4. 用密文分组1和明文分组2进行异或运算，异或完后再进行加密得到密文分组2。

5. 同样的用密文分组2和明文分组3进行异或运算，异或完后再进行加密得到密文分组3，以此类推。

:::


解密的过程：

::: details

1. 首先拿密文分组1来解密。

2. 密文分组1解密得到的结果和初始化向量做异或运算，就得到明文分组1。

3. 密文分组2进行解密。

4. 密文分组2解密得到的结果和密文分组1做异或运算，就得到明文分组2，以此类推。

:::

这种**依赖**前一个密文分组进行的异或运算就叫做**CBC模式**，这种模式有个好处就是即使相同的明文块在不同位置或不同消息中也会**产生不同的密文块**，并且**具备数据完整保护性**。适用于常规**文件加密**，**非实时**加密场景。

之前通过**重排序**攻击的手段，明显对这种模式是无效的，因为会导致密文块的**顺序**被**破坏**，从而导致解密失败。

:::  warning 那CBC模式有什么缺陷呢？
:::


::: details
答案是：**有缺陷**，可以看下面这张图👇：

<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/07/e945024575166790bc0d03a3374788a.png' width="700" style="cursor: zoom-in;"></p>

从图中可以看到攻击者截获了初始化向量，并对它的某一比特位进行了反转，那么解密后的第一个明文块的相应比特位也会被**反转**，从而导致后续所有块相对应的位置都受到影响。<mark><span style="color:red;">也就是说攻击者可以通过操作初始化向量来影响明文，并且不需要密钥</span></mark>，这就是**CBC模式**的缺陷所在。

那有什么办法解决这个问题呢？答案是**CFB模式**👇。
:::



#### 密文反馈模式（CFB）

<!-- ::: details 描述 -->

**密文反馈模式**得名的原因在于此模式中，是以前一个密文分组的输出作为反馈，送回密码算法的输入端以生成用于异或操作的密钥流。

<!-- ::: -->

<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/07/4a00827a6a0f293a181bb0933d38c89.png' width="650" style="cursor: zoom-in;"></p>

<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/11/5af5e8792d566b188635dfcb62b74e8.png' width="650" style="cursor: zoom-in;"></p>

**CFB模式**它直接对初始化向量进行加密，加密完的结果跟明文分组1做异或操作，得出密文分组1，密文分组1进行加密后和明文分组2进行异或操作，得出密文分组2，以此类推。

解密过程和加密过程非常相似，但**方向相反**，首先也是对初始化向量进行加密，再和密文分组1做异或操作，得到明文分组1。密文分组1先加密，再和密文分组2做异或操作，得到明文分组2，以此类推。

之前通过控制初始化向量来影响明文的攻击手段就**无效了**，因为把初始向量中的某个比特位**反转**，会导致加密后的密钥流发生变化，从而导致解密的时候失败。

:::  warning 那CFB模式还有什么缺陷呢？
:::

::: details
答案是：**还是有缺陷的**，可以看下面这张图👇：

<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/11/d7dd240cd2b8f0a13c36de753d9f73d.png' width="700" style="cursor: zoom-in;"></p>

从图中可以看到攻击者截获了数据包，并用以前有效的密文分组对现有的密文分组进行了替换，这就造成了明文分组2的解密出现了错误，但后续的分组还是能正确解密。从某种程度上说，这也是不通过密钥就可以操纵明文，这明显是不对的。

那有什么办法可以解决这种问题，答案是**OFB**模式👇。
:::


#### 输出反馈模式（OFB模式）

**输出反馈模式**之所以得名，是因为在这个模式中，加密算法的输出（即密钥流块）被反馈回算法的输入端，作为产生下一个密钥流块的材料，而不是像其他模式那样直接或间接地与明文或密文数据结合。


<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/11/39708d679f6e04c5224816e1e1d10f3.png' width="700" style="cursor: zoom-in;"></p>

<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/11/f6a5c297428560f05188d0835d2cfa2.png' width="700" style="cursor: zoom-in;"></p>

上图中也是对初始化向量进行加密，加密完后和明文分组1做异或运算，得出密文分组1，接着再对初始化向量进行加密，然后和明文分组2做异或运算，得出密文分组2，这种反复对初始化向量进行加密，再和明文做异或运算的行为就是**OFB模式**。

解密也是如此，只是和初始化向量做异或运算的由明文变成了密文。

**OFB模式**由于密钥流**独立**于明文，加密过程不直接作用于明文，而是通过密钥流与明文异或，这意味着相同的明文在不同的密钥流下会产生不同的密文，这有助于**抵抗模式识别攻击**和**重放攻击**。

:::  warning 那OFB模式还有什么缺陷呢？
:::

::: details

答案是：**有缺陷**，在**OFB模式**中，每个密钥流块的生成依赖于前一个密钥流块。这种依赖关系导致无法完全并行生成密钥流块。具体来说，必须按照顺序生成密钥流块，只有在生成了前一个密钥流块之后，才能生成下一个密钥流块。尽管在生成密钥流之后，异或操作可以并行执行，但密钥流的生成步骤本身是**串行**的。这种串行依赖性限制了OFB模式在密钥流生成阶段的**并行处理能力**。

那有什么办法可以提高并行处理能力？答案是下面的**CTR模式**👇。

:::
#### 计数器模式（CTR模式）

**计数器模式**得名于其核心操作机制，即在加密过程中使用了一个**递增**的计数器。这个计数器与一个初始向量（IV）结合，为每个明文块生成一个唯一的输入值到块密码算法中。每次加密一个新的数据块之前，计数器的值会增加，比如从0开始，然后1、2、3，依此类推，或基于具体的计数规则递增。

<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/12/f84f7b3815dc1f1917584253ff6d8b9.png' width="700" style="cursor: zoom-in;"></p>

<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/12/a23819b1024be58673db362a9fa462b.png' width="700" style="cursor: zoom-in;"></p>

上图中和**OFB模式**的加密过程类似，只是密钥流分组的生成方式不同，OFB模式密钥流分组是通过将前一个密钥流分组加密得到的。也就是说，它是基于前一次加密操作的输出作为下一次加密的输入，形成一个**反馈环路**。

而**CTR模式**是通过**递增的计数器**和初始向量结合后，将这个组合值作为输入加密得到。计数器每次加密前递增，确保每次加密操作使用的是独一无二的输入，从而产生不同的密钥流分组，即使加密相同的明文分组也会产生不同的密文。

计数器模式中，计数器是如何生成的？

<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/12/3813d265b20e77ccf56c21ae58b7802.png' width="500" style="cursor: zoom-in;"></p>

上图前8个字节为随机数，这个值在每次加密时必须都是不同的，后8个字节为分组序号，这个部分是会逐次累加的。在加密的过程中，计数器的值会产生如下变化：

```
66 1F 98 CD 37 A3 8B 4B 00 00 00 00 00 00 00 01 明文分组1的计数器（初始值）
61 2F 22 54 21 46 5F 6E 00 00 00 00 00 00 00 02 明文分组2的计数器
63 1C 31 ED TR 57 23 1F 00 00 00 00 00 00 00 03 明文分组3的计数器
42 1E E1 BC 13 12 81 24 00 00 00 00 00 00 00 04 明文分组4的计数器
```

CTR模式的这种计数器生成和使用方法确保了密钥流的**唯一性**和**安全性**，并且加密和解密过程都可以**并行**处理，**效率高**。

#### 总结
不同的加密模式适用于不同的应用场景，选择合适的加密模式需要考虑安全性、实现复杂度、处理速度和具体应用场景的需求。以下是一些选择的原则：

1、通用数据加密（如文件存储、数据库加密）:
- CBC模式: 提供了较好的数据混淆，防止模式识别，适合大多数加密需求。但注意，对于大数据量处理，CBC模式的顺序执行可能影响性能。

2、实时通信（如网络数据传输）:
- CTR模式: 由于其并行性和高效性，CTR模式非常适合需要高速处理的实时数据加密，如网络流量加密。
- OFB模式: 同样支持并行处理，适用于需要流式加密的场景，但不如CTR常见，因为CTR模式更灵活且在现代系统中更受欢迎。

3、资源受限设备（如嵌入式系统）:
- ECB模式: 对于极度资源受限的环境，虽然安全性较低，但ECB模式简单，易于实现，且不需要维护状态，适合简单或一次性数据加密。
- CFB模式: 在资源有限但需要一定安全性和错误隔离的情况下，CFB可以作为折衷方案，因为它相比ECB提供了更好的安全性，但比CBC和CTR的资源消耗低。

### 公钥密码

公钥密码，也称为**非对称密码**，是一种加密技术，它使用一对密钥：**公钥**（public key）和**私钥**（private key）。因为 **加密** 和 **解密** 使用的是两个不同的密钥，所以这种算法称为 **非对称加密算法**，常见的 **非对称算法** 主要有 `RSA`、`DSA`、`ECC  ` 等。 

#### 一点历史
:::  tip  1976年以前，所有的加密方法都是同一种模式：

1. 甲方选择某一种加密规则，对信息进行加密

2. 乙方使用同一种规则，对信息进行解密
:::

由于加密和解密使用同样规则（简称"密钥"），这被称为["对称加密算法"](http://zh.wikipedia.org/zh-cn/%E5%AF%B9%E7%AD%89%E5%8A%A0%E5%AF%86)（Symmetric-key algorithm）。

这种加密模式有一个最大弱点：甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。

<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/12/bg2013062703.jpg' width="500" style="cursor: zoom-in;"></p>

1976年，两位美国计算机学家Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不直接传递密钥的情况下，完成解密。这被称为["Diffie-Hellman密钥交换算法"](http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange)。这个算法启发了其他科学家。人们认识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。


这种新的加密模式被称为"非对称加密算法"。
:::  tip 工作流程
（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。

（2）甲方获取乙方的公钥，然后用它对信息加密。

（3）乙方得到加密后的信息，用私钥解密。
:::
如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。 

<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/12/bg2013062702.jpg' width="500" style="cursor: zoom-in;"></p>

1977年，三位数学家Rivest（罗纳德·李维斯特）、Shamir（阿迪·萨莫尔） 和 Adleman（伦纳德·阿德曼） 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做[RSA算法](http://zh.wikipedia.org/zh-cn/RSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95)。从那时直到现在，RSA算法一直是最广为使用的"非对称加密算法"。毫不夸张地说，只要有计算机网络的地方，就有RSA算法。

这种算法非常[可靠](http://en.wikipedia.org/wiki/RSA_Factoring_Challenge)，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。

<p class="centered"><img src='https://tuchuang.voooe.cn/images/2024/06/13/4c19788c01e101a8cd8f2964619f3d7.png' width="500" style="cursor: zoom-in;"></p>

上图是2048位的密钥，早在1991年，RSA实验室就公布了一份数字列表，并向任何人提出挑战，以20万美元的奖金计算这些数字。

#### 原理 
讲原理前，需要知道一些数学知识，先回顾一下小学的数学知识😀


1、因数
```
给定方程 a × b = c，数字 a 和 b 被定义为因数，因为它们的乘积等于 c。

例如:

当 2 × 3 = 6 时，数字 2 和 3 构成了 6 的一组因数。同样，对于 1 × 6 = 6，数字 1 和 6 也是 6 的另一组因数。

因此，数字 6 拥有至少两组因数。
```

2、质数
```
1 × a = a 根据质数的定义，如果一个大于1的整数 a 仅有两个不同的正因数，即1和 a 本身，那么该整数 a 被视为质数。

例如：

1 × 5 = 5，我们看到 5 大于 1，并且其唯一的正因数是 1 和 5。

因此，根据上述质数的定义，数字 5 是一个质数。
```

3、余数
```
在表达式 a % b = c 中，% 表示取模运算，也称为模运算或求余运算。

例如:

计算3除以2的余数，过程如下：

除法运算：

3 ÷ 2 = 1.5

取整数部分：

1.5的整数部分是1

计算乘积：

2 × 1 = 2

计算余数：

3 - 2 = 1

因此，3除以2的余数是1。

用公式表示：

3÷2=1(商)

3−(2×1)=1 (余数)

所以，3 % 2 = 1。
```

理清了因数、质数、余数的概念，我们尝试下加密和解密数据吧。



假设我们拿到了公钥 **（7，33）**，私钥里面也有两个数字 **（？，33）**，这里面公钥和私钥的33数字是相同的，也是公开的。

只有这个 **？** 数字是不能公开的。

假设要发送 **"草"** 字给对方，小草的草，这里我们用拼音代替，C,A,O，为了不让别人知道我发的是什么，就需要加密。

首先把这个"CAO"转换为十进制，为了方便演示，假设A为1，B为2，C为3，以此类推,下面是加密解密过程👇

| 加密 |加密  | 解密 |解密  |
| :-----: | :-----: | :-----: | :-----: |
| 公钥   | （7，33）   |私钥   | （3，33） |
| 源数据   | C , A , O   |密文   | 9 , 1 , 27 |
| 十进制   | 3 , 1 , 15   |求幂   | 9<sup>3</sup> , 1<sup>3</sup> , 27<sup>3</sup>  |
| 求幂   | 3<sup>7</sup> , 1<sup>7</sup> , 15<sup>7</sup>   |求幂结果   | 729，1，19683 |
| 求幂结果   | 2187 , 1 , 170859375   |求余   | 729%33，1%33，19683%33 |
| 求余   | 2187%33 , 1%33 , 170859375%33   | 求余结果（十进制）   |3，1，15  |
| 求余结果（密文）   | 9 , 1 , 27   |明文   |C , A , O |


从上述计算过程，我们可以得出一个公式：**明文<sup>E</sup> % N = 密文**，这里的 **"E"** 表示的是公钥，也就是7，**"N"** 表示的是公钥的第二个数字33。

相同的，解密的公式：**密文<sup>D</sup> % N = 明文**,这里的 **"D"** 表示的 是私钥，也就是3，是不能公开的，**"N"** 就是私钥的另一个数字33。

可以看出 **"E"** 和 **"N"** 都是公开的，那黑客拿到密文以后不就可以倒推明文了吗？难就难在这里，生成一个数字并不难，倒推就很难了，这个难度就像把一个鸡蛋打碎再将它复原一样。

<p class="centered"><img src='https://cdn.nlark.com/yuque/0/2024/gif/40965929/1718333645158-3748c1e4-565d-4dec-8d6c-26abc3580ca9.gif' width="500" style="cursor: zoom-in;"></p>

之前价值20万刀的那串数字，其实就是公钥里的 **"N"**,2048比特位，要解开这串数字的秘密，使用一般的电脑破译需要300万亿年。要想更清晰的知道破译有多难，那就必须知道公钥和私钥的制作过程。

``` 
这个过程可以分为5步:

（1）2个质数： p = 3; q = 11

（2）质数相乘： N = p × q = 3 × 11 = 33

（3）欧拉函数： T = (p-1) × (q-1) = 2 × 10 = 20

（4）选公钥E，注意，这里的E不是单纯计算出来的，而是选出来的。

    所以需满足三个条件：

      1、 必须是质数

      2、 1 < 公钥 < T 

      3、 不是 T 的因子

    选出 E = (3,33)

（5）算私钥D： （D × E）% T = 1  得到 D = （7，33）
```
#### 总结

上面的过程是如何生成公钥和私钥的，这里就不细说了，大家可以自己尝试下。这个算法重要的是不能被人知道或者算出私钥的 **"D"** 数字,要算出 **"D"** ，就需要 **"E"** 和 **"T"** ，
因为 **"E"** 是公开的，所以 **"T"** 是算出私钥 **"D"** 的重要数字，而要算出 **"T"**，就需要 **"p"** 和 **"q"** 两个质数。
关键就是这两个质数，如果这个两个质数设置的非常大，不管是 **"N"** 还是 **"T"** 都会变得非常巨大，即使公开 **"N**" ，也很难找到对应的两个质数。而这就是 `RSA` 算法的奥义。